import type { Edge } from '@xyflow/react';
import type { AppNode } from '../nodes/types';

interface CodeGenOptions {
  workflowName: string;
  includeComments: boolean;
}

export class WorkflowCodeGenerator {
  private nodes: AppNode[];
  private edges: Edge[];

  constructor(nodes: AppNode[], edges: Edge[]) {
    this.nodes = nodes;
    this.edges = edges;
  }

  generate(options: CodeGenOptions): string {
    const { workflowName, includeComments } = options;

    let code = '';

    if (includeComments) {
      code += `/**\n * Workflow: ${workflowName}\n * Generated by Workflow Editor\n * ${new Date().toISOString()}\n */\n\n`;
    }

    // Función principal
    code += `function ${this.sanitizeName(workflowName)}() {\n`;

    if (includeComments) {
      code += `  // Obtener información de disparo\n`;
    }

    const triggerNode = this.findTriggerNode();
    if (triggerNode) {
      code += this.generateNodeCode(triggerNode);
    }

    // Generar código en orden topológico
    const executionOrder = this.topologicalSort();

    for (const nodeId of executionOrder) {
      if (nodeId === triggerNode?.id) continue;

      const node = this.nodes.find((n) => n.id === nodeId);
      if (node) {
        code += this.generateNodeCode(node);
      }
    }

    code += `}\n\n`;
    code += this.generateHelperFunctions();

    return code;
  }

  private generateNodeCode(node: AppNode): string {
    const data = node.data as any;
    let code = `  // ${data.label}\n`;

    switch (node.type) {
      case 'trigger':
        code += `  const trigger = getTriggerData();\n`;
        if (data.outputs) {
          data.outputs.forEach((output: string) => {
            code += `  const ${output} = trigger.${output};\n`;
          });
        }
        break;

      case 'action':
        code += `  const result_${node.id} = execute${this.sanitizeName(data.label)}({`;

        if (data.inputs) {
          code += data.inputs
            .map((input: string) => `${input}: ${input}`)
            .join(', ');
        }

        code += `});\n`;

        if (data.outputs) {
          data.outputs.forEach((output: string) => {
            code += `  const ${output} = result_${node.id}.${output};\n`;
          });
        }
        break;

      case 'conditional':
        code += `  if (${data.condition || 'true'}) {\n    // Rama verdadera\n  } else {\n    // Rama falsa\n  }\n`;
        break;

      case 'script':
        code += `  ${data.code || '// Código personalizado'}\n`;
        break;

      case 'output':
        code += `  return { status: 'success' };\n`;
        break;

      default:
        break;
    }

    code += '\n';
    return code;
  }

  private generateHelperFunctions(): string {
    let helpers = '';

    helpers += `function getTriggerData() {\n`;
    helpers += `  // Obtener datos del disparo (email, formulario, etc.)\n`;
    helpers += `  return {};\n`;
    helpers += `}\n\n`;

    // Generar funciones para cada acción
    const actionNodes = this.nodes.filter((n) => n.type === 'action');
    actionNodes.forEach((node) => {
      const data = node.data as any;
      const functionName = `execute${this.sanitizeName(data.label)}`;

      helpers += `function ${functionName}(inputs) {\n`;
      helpers += `  // Implementar acción: ${data.label}\n`;
      helpers += `  Logger.log('Ejecutando: ${data.label}');\n`;
      helpers += `  return {};\n`;
      helpers += `}\n\n`;
    });

    return helpers;
  }

  private findTriggerNode(): AppNode | undefined {
    return this.nodes.find((n) => n.type === 'trigger');
  }

  private topologicalSort(): string[] {
    const visited = new Set<string>();
    const stack: string[] = [];

    const visit = (nodeId: string) => {
      if (visited.has(nodeId)) return;
      visited.add(nodeId);

      const children = this.edges
        .filter((e) => e.source === nodeId)
        .map((e) => e.target);

      for (const childId of children) {
        visit(childId);
      }

      stack.push(nodeId);
    };

    for (const node of this.nodes) {
      visit(node.id);
    }

    return stack.reverse();
  }

  private sanitizeName(name: string): string {
    return name
      .replace(/[^a-zA-Z0-9_]/g, '')
      .replace(/^[0-9]/, '')
      .replace(/\s+/g, '_')
      .toUpperCase();
  }

  validateWorkflow(): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Verificar que hay un nodo disparador
    if (!this.findTriggerNode()) {
      errors.push('Falta un nodo disparador (trigger)');
    }

    // Verificar que hay un nodo de salida
    const hasOutput = this.nodes.some((n) => n.type === 'output');
    if (!hasOutput) {
      errors.push('Falta un nodo de salida');
    }

    // Verificar nodos huérfanos
    const connectedNodes = new Set<string>();
    this.edges.forEach((edge) => {
      connectedNodes.add(edge.source);
      connectedNodes.add(edge.target);
    });

    this.nodes.forEach((node) => {
      if (!connectedNodes.has(node.id) && node.type !== 'trigger') {
        errors.push(`El nodo "${node.data.label}" no está conectado`);
      }
    });

    return {
      valid: errors.length === 0,
      errors,
    };
  }
}

export function generateWorkflowCode(
  nodes: AppNode[],
  edges: Edge[],
  options: CodeGenOptions
): string {
  const generator = new WorkflowCodeGenerator(nodes, edges);
  return generator.generate(options);
}

export function validateWorkflow(
  nodes: AppNode[],
  edges: Edge[]
): { valid: boolean; errors: string[] } {
  const generator = new WorkflowCodeGenerator(nodes, edges);
  return generator.validateWorkflow();
}
